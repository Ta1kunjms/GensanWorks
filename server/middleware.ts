import { Request, Response, NextFunction } from "express";
import { verifyToken, JWTPayload, createErrorResponse, ErrorCodes } from "./auth";

// ============ EXTEND EXPRESS REQUEST TYPE ============

declare global {
  namespace Express {
    interface Request {
      user?: JWTPayload;
    }
  }
}

// ============ AUTH MIDDLEWARE ============

export function authMiddleware(req: Request, res: Response, next: NextFunction) {
  try {
    const authHeader = req.headers.authorization;
    const token = authHeader?.startsWith("Bearer ") ? authHeader.slice(7) : null;

    if (!token) {
      return res.status(401).json(
        createErrorResponse(
          ErrorCodes.UNAUTHORIZED,
          "Missing authentication token"
        )
      );
    }

    const payload = verifyToken(token);
    if (!payload) {
      return res.status(401).json(
        createErrorResponse(
          ErrorCodes.UNAUTHORIZED,
          "Invalid or expired authentication token"
        )
      );
    }

    req.user = payload;
    next();
  } catch (error) {
    return res.status(500).json(
      createErrorResponse(
        ErrorCodes.INTERNAL_SERVER_ERROR,
        "Authentication verification failed"
      )
    );
  }
}

// ============ ROLE MIDDLEWARE ============

export function roleMiddleware(...allowedRoles: string[]) {
  return (req: Request, res: Response, next: NextFunction) => {
    if (!req.user) {
      return res.status(401).json(
        createErrorResponse(
          ErrorCodes.UNAUTHORIZED,
          "User not authenticated"
        )
      );
    }

    if (!allowedRoles.includes(req.user.role)) {
      return res.status(403).json(
        createErrorResponse(
          ErrorCodes.FORBIDDEN,
          `This endpoint requires one of these roles: ${allowedRoles.join(", ")}`
        )
      );
    }

    next();
  };
}

// ============ ADMIN ONLY MIDDLEWARE ============

export function adminOnly(req: Request, res: Response, next: NextFunction) {
  if (!req.user) {
    return res.status(401).json(
      createErrorResponse(
        ErrorCodes.UNAUTHORIZED,
        "User not authenticated"
      )
    );
  }

  if (req.user.role !== "admin") {
    return res.status(403).json(
      createErrorResponse(
        ErrorCodes.FORBIDDEN,
        "This endpoint is restricted to administrators only"
      )
    );
  }

  next();
}

// ============ ERROR HANDLER MIDDLEWARE ============

export interface CustomError extends Error {
  status?: number;
  code?: string;
  field?: string;
}

export function errorHandler(
  err: CustomError,
  req: Request,
  res: Response,
  next: NextFunction
) {
  const isDev = process.env.NODE_ENV === "development";
  const status = err.status || 500;
  const code = err.code || ErrorCodes.INTERNAL_SERVER_ERROR;
  const message = err.message || "An unexpected error occurred";

  console.error(`[${status}] ${code}:`, {
    message,
    stack: isDev ? err.stack : undefined,
    method: req.method,
    path: req.path,
  });

  const response = createErrorResponse(code, message, err.field);

  if (isDev) {
    (response as any).stack = err.stack;
  }

  res.status(status).json(response);
}

// ============ REQUEST LOGGING MIDDLEWARE ============

export function requestLogger(req: Request, res: Response, next: NextFunction) {
  const start = Date.now();
  const originalSend = res.send;

  res.send = function (data) {
    const duration = Date.now() - start;
    const logEntry = {
      timestamp: new Date().toISOString(),
      method: req.method,
      path: req.path,
      status: res.statusCode,
      duration: `${duration}ms`,
      user: req.user?.id || "anonymous",
      role: req.user?.role || "none",
    };

    // Log important events
    if (req.path.includes("/api/auth")) {
      console.log("[AUTH]", logEntry);
    } else if (req.path.includes("/api/admin")) {
      console.log("[ADMIN]", logEntry);
    } else if (res.statusCode >= 400) {
      console.log("[ERROR]", logEntry);
    }

    return originalSend.call(this, data);
  };

  next();
}

// ============ VALIDATION ERROR MIDDLEWARE ============

export function validationErrorHandler(
  err: any,
  req: Request,
  res: Response,
  next: NextFunction
) {
  // Handle Zod validation errors
  if (err.name === "ZodError") {
    const firstError = err.errors[0];
    return res.status(400).json(
      createErrorResponse(
        ErrorCodes.MISSING_FIELD,
        `${firstError.path.join(".")} - ${firstError.message}`,
        firstError.path[0]
      )
    );
  }

  next(err);
}
